<script>
  "use strict";

  class ServerPenetrationSimulation {
    constructor() {
      // Global dimensions and padding for our canvases.
      this.simWidth = 600;
      this.simHeight = 400;
      this.histWidth = 600;
      this.histHeight = 300;
      this.padding = 50;
      
      // Default simulation parameters.
      this.n = 50; // servers
      this.m = 10; // attackers
      this.p = 0.5; // penetration probability
      
      // Other state variables.
      this.colors = [];
      this.checkboxes = [];
      this.penetrationResults = []; // 2D array: [attacker][server] = 0 or 1
      
      // DOM elements.
      this.serversInput = document.getElementById("servers");
      this.attackersInput = document.getElementById("attackers");
      this.probabilityInput = document.getElementById("probability");
      this.startButton = document.getElementById("startButton");
      this.checkboxContainer = document.getElementById("checkboxContainer");
      this.simCanvas = document.getElementById("simulationCanvas");
      this.histContainer = document.getElementById("histogramContainer");
      
      // Set up high-resolution simulation canvas.
      this.simCtx = this.setupCanvas(this.simCanvas, this.simWidth, this.simHeight);
    }

    // Initialize event listeners and auto-run simulation on page load.
    init() {
      this.startButton.addEventListener("click", () => this.startSimulation());
      this.startSimulation();
    }

    // Setup canvas with devicePixelRatio scaling.
    setupCanvas(canvas, width, height) {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      const ctx = canvas.getContext("2d");
      ctx.scale(dpr, dpr);
      return ctx;
    }

    // Main function to run the simulation.
    startSimulation() {
      // Read simulation parameters.
      this.n = parseInt(this.serversInput.value, 10);
      this.m = parseInt(this.attackersInput.value, 10);
      this.p = parseFloat(this.probabilityInput.value);
      
      // Generate unique colors for each attacker.
      this.colors = this.generateUniqueColors(this.m);
      
      // Initialize the penetration results as an m x n array of zeros.
      this.penetrationResults = Array.from({ length: this.m }, () => Array(this.n).fill(0));

      // Create checkboxes to toggle each attacker's line.
      this.checkboxContainer.innerHTML = "";
      this.checkboxes = [];
      for (let i = 0; i < this.m; i++) {
        const label = document.createElement("label");
        label.textContent = "Hacker " + (i + 1);
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = true;
        checkbox.addEventListener("change", () => {
          this.clearSimArea();
          this.drawSimAxes();
          this.drawSimulation();
        });
        this.checkboxes.push(checkbox);
        label.prepend(checkbox);
        this.checkboxContainer.appendChild(label);
      }

      // Generate penetration results: For each attacker and server, set result to 1 with probability p.
      for (let attacker = 0; attacker < this.m; attacker++) {
        for (let server = 0; server < this.n; server++) {
          if (Math.random() < this.p) {
            this.penetrationResults[attacker][server] = 1;
          }
        }
      }

      // Clear and redraw the simulation canvas.
      this.clearSimArea();
      this.drawSimAxes();
      this.drawSimulation();

      // Draw the histogram.
      this.drawHistogram();
    }

    // Clear the simulation drawing area.
    clearSimArea() {
      this.simCtx.clearRect(0, 0, this.simWidth, this.simHeight);
    }

    // Draw axes (with tick marks and labels) on the simulation canvas.
    drawSimAxes() {
      // X-axis.
      this.simCtx.beginPath();
      this.simCtx.moveTo(this.padding, this.simHeight - this.padding);
      this.simCtx.lineTo(this.simWidth - this.padding, this.simHeight - this.padding);
      this.simCtx.stroke();
      // Y-axis.
      this.simCtx.beginPath();
      this.simCtx.moveTo(this.padding, this.simHeight - this.padding);
      this.simCtx.lineTo(this.padding, this.padding);
      this.simCtx.stroke();

      // Axis labels.
      this.simCtx.font = "16px Arial";
      this.simCtx.textAlign = "center";
      this.simCtx.fillText("Server", this.simWidth / 2, this.simHeight - 10);
      this.simCtx.save();
      this.simCtx.translate(15, this.simHeight / 2);
      this.simCtx.rotate(-Math.PI / 2);
      this.simCtx.fillText("Penetration Count", 0, 0);
      this.simCtx.restore();

      // X-axis tick marks and server indices.
      const stepX = (this.simWidth - 2 * this.padding) / this.n;
      this.simCtx.font = "12px Arial";
      for (let i = 0; i < this.n; i++) {
        const x = this.padding + (i + 0.5) * stepX;
      }

      // Y-axis tick marks (penetration counts).
      const maxPenetrations = this.n; // Maximum possible penetrations per attacker.
      const stepY = (this.simHeight - 2 * this.padding) / maxPenetrations;
      this.simCtx.textAlign = "right";
      for (let j = 0; j <= maxPenetrations; j++) {
        const y = this.simHeight - this.padding - j * stepY;
      }
    }

    // Draw simulation lines for each attacker.
    drawSimulation() {
      // Clear the drawing area (but do not clear the axes).
      this.simCtx.clearRect(this.padding, this.padding, this.simWidth - 2 * this.padding, this.simHeight - 2 * this.padding);
      this.drawSimAxes();

      const lineWidth = (this.simWidth - 2 * this.padding) / this.n;
      const maxPenetrations = this.n;
      const lineHeight = (this.simHeight - 2 * this.padding) / maxPenetrations;
      
      for (let attacker = 0; attacker < this.m; attacker++) {
        if (!this.checkboxes[attacker].checked) continue;
        let x = this.padding;
        let y = this.simHeight - this.padding;
        let count = 0;
        for (let server = 0; server < this.n; server++) {
          if (this.penetrationResults[attacker][server] === 1) {
            count++;
          }
          const newY = this.simHeight - this.padding - count * lineHeight;
          this.drawLine(x, y, x + lineWidth, newY, this.colors[attacker]);
          x += lineWidth;
          y = newY;
        }
      }
    }

    // Draw a single line segment.
    drawLine(startX, startY, endX, endY, color) {
      this.simCtx.beginPath();
      this.simCtx.moveTo(startX, startY);
      this.simCtx.lineTo(endX, endY);
      this.simCtx.strokeStyle = color;
      this.simCtx.lineWidth = 2;
      this.simCtx.lineCap = "round";
      this.simCtx.stroke();
    }

    // Draw a vertical histogram showing, for each server, the total penetration count.
    drawHistogram() {
      this.histContainer.innerHTML = "";
      const histCanvas = document.createElement("canvas");
      histCanvas.style.border = "1px solid #000";
      this.histContainer.appendChild(histCanvas);
      const histCtx = this.setupCanvas(histCanvas, this.histWidth, this.histHeight);

      // Draw histogram axes.
      histCtx.beginPath();
      histCtx.moveTo(50, this.histHeight - 40);
      histCtx.lineTo(this.histWidth - 20, this.histHeight - 40);
      histCtx.stroke();
      histCtx.beginPath();
      histCtx.moveTo(50, this.histHeight - 40);
      histCtx.lineTo(50, 20);
      histCtx.stroke();

      // Axis labels.
      histCtx.font = "16px Arial";
      histCtx.textAlign = "center";
      histCtx.fillText("Server", this.histWidth / 2, this.histHeight - 10);
      histCtx.save();
      histCtx.translate(15, this.histHeight / 2);
      histCtx.rotate(-Math.PI / 2);
      histCtx.fillText("Penetration Count", 0, 0);
      histCtx.restore();

      // Build histogram data: for each server, sum penetrations over all attackers.
      const histData = Array.from({ length: this.n }, () => 0);
      for (let server = 0; server < this.n; server++) {
        let count = 0;
        for (let attacker = 0; attacker < this.m; attacker++) {
          if (this.penetrationResults[attacker][server] === 1) {
            count++;
          }
        }
        histData[server] = count;
      }

      // Determine bar dimensions.
      const stepX = (this.histWidth - 70) / this.n;
      const stepY = (this.histHeight - 60) / (this.m || 1);

      // Draw a bar for each server.
      for (let i = 0; i < this.n; i++) {
        const x = 50 + i * stepX;
        const barHeight = histData[i] * stepY;
        histCtx.fillStyle = "#4285F4";
        histCtx.fillRect(x, this.histHeight - barHeight - 40, stepX - 2, barHeight);
        // Draw server index below each bar.
        histCtx.fillStyle = "#000";
        histCtx.textAlign = "center";
        histCtx.font = "14px Arial";
      }
    }

    // Generate an array of unique colors using HSL.
    generateUniqueColors(num) {
      const colors = [];
      while (colors.length < num) {
        const color = `hsl(${Math.random() * 360}, 100%, 50%)`;
        if (!colors.includes(color)) {
          colors.push(color);
        }
      }
      return colors;
    }
  }

  // Instantiate and initialize the simulation.
  const simulation = new ServerPenetrationSimulation();
  simulation.init();
</script>
